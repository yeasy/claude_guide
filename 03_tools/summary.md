## 本章小结：从对话到行动

在这一章中，我们跨越了大型语言模型（LLM）最重要的分水岭：从“被动问答”进化为“主动代理”。通过掌握工具使用（Tool Use），Claude 不再被禁锢在预训练的文本框中，而是获得了感知世界、操纵数据和执行任务的“双手”。

### 核心知识点回顾

#### 工具的本质
工具不仅仅是 API 调用，更是 Claude **逻辑推理能力的延伸**。
*   **客户端工具**：你掌握控制权，Claude 负责意图识别和参数生成。
*   **服务端工具**：Anthropic 提供的开箱即用能力（如联网搜索）。

#### 定义的力量 (Schema)
*   **Description is Prompt**：工具描述是系统提示词的一部分，决定了调用的准确率。
*   **JSON Schema**：精确的参数类型定义（Enum, Required, Format）是防止幻觉的第一道防线。

#### 请-算-行-馈 (The ReAct Loop)
我们深入剖析了 Agent 运行的生命周期：
1.  **Stop Reason**: 识别 `tool_use` 信号。
2.  **Execution**: 并行或串行执行业务逻辑。
3.  **Result**: 构造包含 Text 或 Image 的 `tool_result`。
4.  **History**: 维护完整的对话链条是成功的关键。

#### 复杂编排
*   **并行模式**：利用 asyncio 降低多工具调用的延迟。
*   **人机协作 (HITL)**：在关键操作前引入人工审批，确保安全。
*   **状态管理**：学会区分哪些状态属于 Context，哪些属于外部数据库。

#### 高级特性
*   **程序化工具调用**：让 Claude 写代码而不是发 JSON，极大提升了处理复杂逻辑和大量数据的效率。
*   **工具搜索**：通过“按需加载”机制，解决了 Token 限制与大规模工具库之间的矛盾，为构建拥有成千上万技能的超级 Agent 铺平了道路。

### 开发者自检清单

在开始构建你的 Agent 之前，请通过以下问题自检：
- [ ] **命名规范**：我的工具名称是否清晰，且不易与现有工具混淆？
- [ ] **描述完整**：description 是否包含了“何时使用”、“参数格式”以及“返回什么”？
- [ ] **错误处理**：当 API 失败时，我是否返回了 `is_error: true` 且带有指导性的错误信息？
- [ ] **Token 预算**：我的工具定义是否过于冗长？是否需要使用工具搜索？
- [ ] **安全性**：是否为了方便而赋予了过大的权限（如 `DROP TABLE`）？是否有人工确认环节？

### 下一站：标准化连接

虽然我们已经学会了如何定义工具，但在现实世界中，连接不同的数据源（Google Drive, Slack, PostgreSQL）往往涉及繁琐的适配工作。

有没有一种通用的标准，让我们能像插 USB 设备一样，即插即用地扩展 Claude 的能力？

答案就是 **MCP (Model Context Protocol)**。

➡️ [进入第 4 章：MCP 模型上下文协议](../04_mcp/README.md)
